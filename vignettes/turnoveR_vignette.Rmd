---
title: "turnoveR: Data Processing"
author: "Corinne Walsh"
output:
  html_document:
    df_print: paged
---


```{r message = FALSE, warning = FALSE}
library(readxl)
library(readr)
library(dplyr)
library(plotly)
library(purrr)
devtools::load_all(".")
```

# Introduction to turnoveR

With the original goal of quantifying protein turnover and protein degradation for as many proteins as possible in a proteome, the turnoveR package has been developed to analyse isotopically labeled proteomics datasets. 

Experimental datasets intended for use with this package are generated from a series of samples taken from a steady-state bacterial culture. Samples are taken at different timepoints following an isotopic label "pulse".  

Functions in the turnoveR package accept mass spectrometry datasets that have been pre-processed to estimate areas of the "heavy" and "light" isotopic labeled fractions for each protein (by programs such as Massacre). 


# Data Input
##Input File Types accepted

#### "protein_sums.csv": 
 - a file containing a sum of how many times each protein was identified in each sample of a dataset 
 - Preferred file type: .csv 
 - Important column names: 

#### "svm_results.csv": 
 - typically a massacre output file curated to remove poorly fitted curves 
 - Preferred file type: .csv 
 - Important column names: 
 
#### "metadata.xlsx": 
 - an excel sheet with sample timepoints, other sampling information 
 - Preferred file type: .xlsx 
 - Important column names: 


# Example: Data Processing 

To get started, load in the data. The pre-processed proteomics data (filtered spectral output from massacre) is read in through the function tor_read_svm_data_file. The metadata should include information on sampling timepoints, and is accepted in an excel format. The protein_sums file should contain the protein names and corresponding abundances for all proteins identified in each sample and is accepted as a csv file. 

To direct the file path to the correct location for each file, list folders and file name in quotes separated by commas. 

##Reading in Files
```{r message = FALSE, warning = FALSE}

svm_data <- tor_read_svm_data_file(file.path("vignette_data", "svm_pred_results_0.03gr.csv"))

metadata <- read_excel(file.path("vignette_data", "metadata_CMW.xlsx"))

protein_sums <- read_csv(file.path("vignette_data", "psms.csv"))

prot_rename_filepath <- file.path("vignette_data", "rename_prot.xlsx")
```

##Calculate Fraction of Labeled Proteins
The first step in the analysis pipeline is to rename the proteins in the svm_results file to an up-to-date protein nomenclature list using the function tor_rename_proteins. This step is important because peptide and isoform names in the proteome database can differ from those generated by the mass spectrometer software, and inconsitencies can cause problems later in analysis. 

Once protein nomenclature is consistant, the svm_results data should be filtered to remove peptides with poor labeling spectral fits. It is possible to specify a cut-off for the fit quality value, with the default set to 0.75. 

With a filtered dataset, you can calculate the heavy and light isotope labeling fractions using tor_calculate_labeled_fraction. This function returns the fraction of labeled and unlabeled peptides (or proteins) for each sample. 

It is often necessary to update column names to improve compatability between files. This is achieved using the select function, by setting the desired name equal to the current column name. 

Finally, the timpoints from the metadata are added to the svm_results data. 

```{r}
svm_data_filtered <- 
  svm_data %>% 
  #update protein names for consistancy
  tor_rename_proteins(prot_rename_filepath) %>% 
  #remove datapoints with bad spectral fits using specified cut off
  tor_filter_peptides_by_spectral_fit(pred_cutoff = 0.75) %>% 
  #calculate heavy and light isotope label fractions
  tor_calculate_labeled_fraction() %>% 
  # adjust names 
  select(unishort = uniShort, protein = prot, gene, isopep = seqz, sample, frac_ulab, frac_lab) %>% 
 # add timepoints from metadata
  left_join(metadata, by = "sample")
```

##Calculate Degradation and Dissipation rates 
With the labeled and unlabeled fractions known for each peptide at each timepoint, it is possible to calculate a labeling *rate*, and thus degradation and dissipation rates for each peptide or protein. For this step, it is critical to know the growth rate of the experiment. The growth rate can be calculated using the culture volume and media flow rate. 

The fuction tor_calculate_label_rate uses the calculated labeled fractions to create a curve describing isoptope labeling over time for each peptide or protein. This curve is used to generate a labeling rate for each peptide. Peptides can be combined to return a labeling rate for the entire protein by choosing the option 'combine_peptides = TRUE' in the function arguments.

The output from the tor_calculate_label_rate function should be filtered to remove curves with insufficient datapoints or poor curve fits. 

The calculated labeling rates can then be used to calculate degradation rates and dissipation rates using the function tor_calculate_degradation_dissipation. Protein degradation is calculated as the labeling rate minus the growth rate (deg_rate = label_rate - growth_rate). Protein dissipation is calculated as the degradation rate divided by the labeling rate, and is displayed as a percent (dissipation = (deg_rate / label_rate)*100). 

```{r}
#Important: need vessel volume and flow rate for growth_rate calculation
growth_rate = 0.46*60 /894.4 
generation_time = log(2) / growth_rate

#generate curves to calculate isotope labeling rate
final_data <- tor_calculate_label_rate(svm_data_filtered, quiet = FALSE) %>%
  #filter out data with bad fits, or not enough data points 
  filter(enough_data, !fit_error) %>% 
  select(-enough_data, -fit_error) %>% 
  
  #calculate degradation and dissipation rates
  tor_calculate_degradation_dissipation(growth_rate) 
  

```

##Calculate Weighted Degradation and Weighted Dissipation based on protein abundance

The protein abundance information can be combined with the dissipation and degradation values to calculate a weighted degradation and dissipation rate for each protein.This weighted calculation uses the relative abundance of each peptide or protein identified in the samples to better describe overall cellular investment in protein turnover for each protein.  

```{r}
final_table <- final_data %>% 
  #add protein_sum information to create weighted calculations
  left_join(protein_sums, by = "protein") %>% 
  mutate(
    #calculate weighted value (relative abundance of each protein)
    relative_abundance =  (T0_counts / sum(T0_counts, na.rm = TRUE)),
    #calculate a weighted degradation rate
    weighted_deg = deg_rate * relative_abundance,
    #calculate a weighted dissipation rate 
    weighted_disp = dissipation * relative_abundance
  ) %>% 
  
  #rename columns - need to make sure column names are consistent
  rename(protein_count = T0_counts) %>% 
  select(-nested_data, -fit)
```


## Degradation Analysis - Looking at data

The total fraction of the proteome that is degraded per generation can be calculated by summing the weighted dissipation values for all proteins. 

To take a quick look at the important proteins contributing to protein turnover, it is possible to list the proteins with the highest degradation rates or dissipation rates in the experiment.

```{r}
#calculate total proteome degradation per generation
sum_dissipation = sum(final_table$weighted_disp, na.rm = TRUE) 
sum_dissipation

#list top proteins by label rate 
label_top50 = top_n(final_table, n = 50, wt = final_table$label_rate)
label_top50

#list top proteins by relative abundance
relative_abundance_top50 = top_n(final_table, n = 50, wt = final_table$relative_abundance)
relative_abundance_top50

#list top proteins by weighted degradation
weighted_degradation_top50 = top_n(final_table, n = 50, wt = final_table$weighted_deg)
weighted_degradation_top50
```


##Data Quality Visualizations
The data quality can be visualized using a few basic graphing functions.

To see a histogram plotting the labeling rates of all the proteins in an experiment, use tor_plot_label_rate_hist. 

The function tor_plot_label_rate_error displays the residual standard error for each calculated label rate. 

To visualize what the labeled curves actually look like, use tor_plot_labeling_curves to see the labeling curve for a randomly selected protein or proteins. The argument 'plot_number' allows the user to select the desired number of curves to display.

```{r}
tor_plot_label_rate_hist(final_data)
tor_plot_label_rate_error(final_data)
tor_plot_labeling_curves(final_data, plot_number = 2)
```

